---
layout: post
title: "제약을 넘어 : Gevent"
tags: ['Python']
date: 2014-11-15 12:53:00
---
# [제약을 넘어 : Gevent](http://www.pycon.kr/2014/program/3)

파이썬은 GIL 때문에 `coroutine`을 써야 한다. 파이썬만 그런게 아니라 하이레벨 언어는 대부분 그렇다는데, 자세히는 모르겠고… 아무튼 파이썬은 그렇다. `gevent`는 이 `coroutine`을 래핑한 라이브러리… 로 알고 있다. 자세한 건 이제 공부해보자.

pycon 2014 발표다.

## Example

일단 예시부터 보고 들어간다.
    
    
    def handle_request(s):
        try:
            s.recv(1024)
            s.send('HTTP/1.0 200 OK\r\n')
            s.send('Content-Type: text/plain\r\n')
            s.send('Content-Length: 5\r\n')
            s.send('\r\n')
            s.send('hello')
            s.close()
        except Exception, e:
            logging.exception(e)
    
    def test():
        s = socket.socket()
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
        s.bind(('0.0.0.0', 8000))
        s.listen(512)
    
        while True:
            cli, addr = s.accept()
            logging.info('accept ', addr)
            t = threading.Thread(target=handle_request, args=(cli, ))
            t.daemon = True
            t.start()
    

리퀘스트가 들어오면 정해진 리스폰스를 보내는 아주 간단한 서버다.  
이 소스를, 단 두줄 만으로 성능을 두배로 향상시킬 수 있다!
    
    
    from gevent.monkey import patch_all
    patch_all()
    

Wow!

## How?

컴퓨팅 작업은 크게 두가지로 나눌 수 있다.

  * `CPU BOUND`: CPU 작업이 수행시간의 주인 경우 - 압축, 정렬 …
  * `I/O BOUND`: I/O 작업이 수행시간의 주인 경우 - 네트워크, 디스크 …

즉 대부분의 Web App은 `I/O BOUND`다!

`I/O BOUND`라는 소리는 결국 CPU가 논다는 소리고, 우리는 이걸 더 잘 활용해야 할 의무가 있다. 놀면 아까우니까. 이를 해결하기 위한 방법이 크게 두가지가 있다.

  * 동시성(Concurrency)
  * 병렬성(Parallelism)

발표자는 이 두 개념을 차선과 버스를 이용해서 설명한다. 1차선에 버스로 사람을 수송하는데, 수송량을 늘리고 싶다면? 첫째, 버스의 수송인원을 늘린다. 둘째, 차선을 늘린다. 첫번째 방법이 동시성이고, 두번째 방법이 병렬성이다. 병렬성은 멀티쓰레딩을 의미하며 차선을 늘린다는 건 쓰레드를 늘린다는 것을 의미한다. 뭐, 그다지 와닿지는 않는 설명이다.

아무튼, 파이썬은 GIL 때문에 멀티쓰레딩은 별로 좋지 않다. 즉, 파이썬의 특성상 병렬성은 버리고 동시성에 집중해야 한다.

## Gevent

그럼 어떻게 동시성을 향상시키는가? `node.js`를 생각하면 간단하다. 이벤트가 발생하면, 이를 처리하다가 I/O 작업이 발생하면 이를 커널에 요청하고 다른 이벤트를 처리한다. 커널은 I/O 작업을 끝내면 콜백을 통해 I/O 작업이 끝났음을 알린다. 우리는 그럼 이 콜백에서 작업을 마무리하면 된다. 즉, 원래는 I/O 작업을 할 때 커널의 리스폰스를 계속 기다리고 있는데 그 시간에 다른 이벤트를 처리하게 하여 CPU를 더 활용하겠다는 거다.

파이썬에서 그렇게 하기 위한 라이브러리가 바로 `gevent`다. `gevent`는 scheduler + event loop로 구성된 라이브러리다.

  


![](http://cfile2.uf.tistory.com/image/23161F3E5466CE1F15A93B)

  


### greenlet

scheduler. micro-thread이고, coroutine을 이용하여 implicit scheduling을 하지 않는다.

`coroutine`?  
함수가 끝나지 않아도 제어권을 넘길 수 있는 기능.

-&gt; Cooperative multitasking  
명시적인 스케줄링

### libdev

event-loop. 현재 시점에서 가장 적절한 이벤트를 선택한다.  
이벤트 루프란?
    
    
    while True:
        events = wait_for_events()
        for event in events:
            handle_event(event)
    

동시성을 향상시키기 위해 이벤트를 처리하다가 I/O 작업이 있으면 커널에 넘기고 다른 이벤트를 처리하고, 이러기 위해서 필요한 게 바로 이벤트 루프다. 이벤트 루프는 커널과 프로세스의 중간에서 이를 가능하게 해 준다. 원래 I/O 작업을 요청하면 리스폰스를 기다려야 하는게 정석이지만, 커널에서 이러한 이벤트 구조를 지원하기 때문에 이벤트 루프는 그런 커널의 기능을 이용한다. 

### monkey_patch()

위 예시에서 멍키패치란걸 하는데, 이 멍키패치는 기존의 소켓이라던가 I/O 작업을 하는 애들을 non-blocking으로 바꿔준다. 즉, 아래에서 보듯이 sock.recv가 gevent를 고려하여 만들어진게 아니기 때문에 이를 gevent와 함께 사용할 수 있도록 바꾸어 주는 것이다.

예를 들면, 소켓의 `sock.recv`를 이렇게 바꾼다:
    
    
    def recv(self, *args):
        while True:
            try:
                return sock.recv(*args)
            except error as ex:
                if ex.args[0] != EWOULDBLOCK:
                    raise
                self._wait(self._read_event)
    

원래는 sock.recv에서 block이 걸려서 기다리는데, 이를 non-blocking으로 바꿔, block이 걸리면 error로 잡힌다. 그럼 아래에서 어떤 error인지 검사하고, 그게 `EWOULDBLOCK`, 즉 block이 걸렸다는 _wait함수를 호출하여 이벤트를 기다린다.

## 참고

위에서는, 즉 세션에서는 저 두 줄만 추가하면 된다고 했지만 실제로 그렇진 않다. `gevent`를 명시적으로 호출해 주어야 한다. 위 예시에서는 어떻게 되는지 잘 모르겠지만, 아무튼 일반적으로 그렇다. [30분만에 따라하는 동시성 웹 스크래퍼](http://www.pycon.kr/2014/program/15)라는 세션도 들었는데, 거기서는 `gevent.pool`을 사용한다. pool이든 뭐든, 아무튼 gevent를 호출하여 nonblocking을 명시해 주어야 한다.

### blocking
    
    
    # blocking
    ...
    talks = [talk_from_page(url) for url in talk_links]
    

### non-blocking
    
    
    # non-blocking
    from gevent.monkey import patch_all; patch_all()
    from gevent.pool import Pool
    ...
    pool = Pool(20)
    talks = pool.map(talk_from_page, talk_links)
    

### flask?

그럼 `flask`에는 어떻게 적용해야 하는가? 여러 리퀘스트를 non-blocking으로 동시에 때리는 방법은 알겠는데, 플라스크에서 적용하려면 요청이 들어올 때마다 각각 따로 non-blocking으로 때려 줘야 한다. 인터넷을 뒤지다 보니 별별 내용이 많아서 따로 공부하기로 한다.


[Tistory 원문보기](http://khanrc.tistory.com/72)
