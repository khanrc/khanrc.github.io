---
layout: post
title: "다양한 Python들!"
tags: ['Python']
date: 2014-08-19 11:07:00
---
# 다양한 Python들!

전부터 컴파일러 수업을 듣고 싶었는데 학교에서는 시간표가 겹쳐서 못 듣고, 콜세라에서 하길래 들어야지 했는데 영 잘 안 듣게 된다. 올해의 목표로 삼아야 겠다.

## Pythons

파이썬은 귀도 반 로썸(Guido van Rossum)에 의해서 1991년 만들어졌다. 이 귀도가 만든게 바로 CPython.  
공식 홈페이지는 python.org.

  * CPython
  * Cython
  * PyPy
    * RPython
  * Stackless Python
  * JPython
  * Jython
  * IronPython
  * IPython

참고로 [루비](http://ko.wikipedia.org/wiki/%EB%A3%A8%EB%B9%84_\(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4) 또한 JRuby, IronRuby, MacRuby, Rubinius, Cardinal 등등 다양한 구현체가 존재한다. 

### CPython

C로 짜여진 파이썬. 우리가 쓰는 파이썬 인터프리터가 바로 이 CPython이다. 바꿔 말하면 파이썬은 C로 짜여졌다 라고 할 수도.

GIL1 때문에 멀티쓰레딩 이슈가 있으나 일반적으로 파이썬은 prototyping용으로 사용하기 때문에 실질적으로 이게 문제가 되는 경우는 거의 없다고 한다. 이브온라인 같이 파이썬을 좀 더 적극적으로 사용하게 되면 Stackless Python등 다양한 시도를 하게 되는 듯.

### [Cython](http://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%EC%8D%AC)

[4세대 컴퓨팅 언어, 싸이쎤(Cython)](http://www.wikitree.co.kr/main/news_view.php?id=149307)  
싸이썬은 파이썬의 수퍼셋(superset)이다. 파이썬이 동적으로 결정되는 부분(변수의 타입이라던가)이 있어서 인터프리팅을 해야 하고, 그래서 느리다면, 그걸 정적으로 결정하고 컴파일을 하면 되지 않는가? 라는 게 바로 싸이썬이다.

[파이썬 컴파일러 'Cython' 기본 원리 소개](http://www.wikitree.co.kr/opm/opm_news_view.php?id=160061&alid=200094&opm=jamessungjinkim)  
인터프리팅이 느리다, 그래서 컴파일이 필요하다. 근데 생각해 보면 그렇다고 전부 다 컴파일 해야 할 필요는 없다. 속도에 치명적인 영향을 주는 부분만 컴파일 하면 되는 것이다. 이 아이디어로부터 나온 것이 C-API이며, Cython이다. 이 외에 MIT의 Julia, 구글의 Go, 자바의 Scala도 이러한 하이브리드 방법을 적용한 언어에 해당한다.

### [PyPy](https://mirror.enha.kr/wiki/PyPy)

[PyPy와 함께 인터프리터 작성하기](http://haruair.com/blog/1882)  
[PyPy가 CPython보다 빠를 수 있는 이유, 홍민희](http://blog.dahlia.kr/post/5124874464)

> 메아리 : [meta-tracing JIT에 대해 좀더 자세한 글, 강성훈](http://j.mearie.org/post/5125952364/why-is-pypy-faster-than-cpython)

파이파이는 파이썬으로 작성된 파이썬 인터프리터다. 그리고 거기에 JIT2이라는 기술을 도입하여 CPython보다 빠르게 만들었다.

현재 파이썬 구현체중 가장 각광받고 있으며 Stackless Python도 파이파이가 거의 잡아먹은 듯. 

#### [RPython](http://ko.wikipedia.org/wiki/RPython)

이 PyPy를 구현하기 위해 나온것이 바로 RPython. Restricted Python이란 의미인데 정적 컴파일이 가능하도록 Python에 제약을 가한 서브셋(subset) 언어다. 컴파일하는 데에 장애가 되는 동적인 기능을 제거한 것.

### [Stackless Python](https://mirror.enha.kr/wiki/Python#s-4.2)

CPython을 구현할 때 파이썬의 함수 호출 스택을 C의 스택에 그대로 얹어버렸기 때문에 파이썬에서 얼마나 메모리를 쓸 수 있느냐와 관련없이 C 스택을 꽉 채우면 그대로 스택 오버플로 에러가 뜨게 된다. 뿐만 아니라 파이썬 프로그램의 호출 스택, 즉 프로그램의 실행 흐름을 CPython 스스로 제어할 수 없게 되어 코루틴 등 실행 흐름을 제어하는 언어 기능을 쓸 수 없다.

이 문제를 해결하기 위해서 CPython 소스를 수정해서 C스택을 쓰는 부분을 전부 들어내고 새로 호출 스택을 짜 넣은것이 Stackless Python이다. 

현재는 PyPy에 밀려 사향길에 접어든 것으로 보인다. 자세히는 위 링크 참조.

### JPython, Jython, IronPython

[자이썬(Jython) 완벽 안내서](http://jythonbook-ko.readthedocs.org/)  
JPython은 Jython의 조상으로 10년 전 문서들에서나 찾아볼 수 있는 단어다. Jython은 자바, IronPython은 닷넷 위에서 돌아간다.  
파이썬은 GIL1때문에 쓰레드를 쓰기 힘든데, Jython과 IronPython은 그런 문제가 없다.

### [IPython](http://en.wikipedia.org/wiki/IPython)

IPython은 지금까지 살펴본 파이썬들과는 달리 새로운 파이썬 인터프리터 혹은 컴파일러가 아니다. IPython은 강력한 추가 기능들을 제공하는 interactive shell이다. 즉, 파이썬 기본 인터프리터의 업그레이드 버전이라고 보면 된다. 

#### [IPython Notebook](http://ipython.org/notebook.html)

IPython의 강력한 기능 중 하나로, 웹 기반 쉘 환경을 제공한다. 파이썬 코드, 텍스트, 수학식, 그래프 그리고 다양한 미디어들을 하나의 도큐먼트로 만들 수 있다. 

[wakari.io](https://www.wakari.io/) : 웹에 IPython Notebook을 올리고 공유할 수 있다.

### 결론

[Python Compatibility Table](http://blog.dahlia.kr/post/7429547149)  
기본적으론 CPython  
퍼포먼스가 필요할 때는 PyPy  
호환성이 필요할 때는 Jython이나 IronPython

* * *

  1. Global Interpreter Lock. coarse-grained-lock중에서도 극단적인 개념이 GIL이다. 즉, 어떤 시점에서든 단 한개의 바이트코드만이 실행된다. [Python에서 thread를 사용하지 마세요?](http://yinjae.wordpress.com/2012/04/02/python-thread/) 참조.↩

  2. Just-In-Time 컴파일러. 파이썬 바이트코드를 인터프리팅 하다가, 자주 사용되는 부분은 컴파일한다. 즉, 처음에는 느리지만 코드가 돌아갈수록 점점 빨라진다. ↩


[Tistory 원문보기](http://khanrc.tistory.com/25)
